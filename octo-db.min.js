/*!
 * OctoDB v1.0.0 - github.com/ostov-larion/octo-db
 * MIT License
 * @preserve
 */
class OctoDB extends EventTarget{constructor(e,t){super(),e&&(this.name=e),t&&(this.scheme=t);let n=this;this.entries=new Proxy({},{set:(e,r,s)=>(n.beforeSet&&(s=n.beforeSet(r,s)),new Promise((e,o)=>{let a=n.db.transaction(n.name,"readwrite").objectStore(n.name);a.put({...s,[t.keyPath]:r}).onsuccess=t=>{e(t.target.result),n.dispatchEvent(onchange),n.dispatchEvent(onset)},a.onerror=e=>o(e)})),get:(e,t)=>t==Symbol.asyncIterator?n[Symbol.asyncIterator].bind(n):new Promise((e,r)=>{let s=n.db.transaction(n.name,"readwrite").objectStore(n.name);s.get(t).onsuccess=t=>e(t.target.result),s.onerror=e=>r(e)}),deleteProperty:(e,t)=>(n.beforeDelete&&n.beforeDelete(t),new Promise((e,r)=>{let s=n.db.transaction(n.name,"readwrite").objectStore(n.name);s.delete(t).onsuccess=t=>{e(t.target.result),n.dispatchEvent(onchange),n.dispatchEvent(ondelete)},s.onerror=e=>r(e)})),has:(e,t)=>proxy[t]})}open(){return new Promise((e,t)=>{let n=indexedDB.open("OctoDB/"+this.name,1);n.onupgradeneeded=t=>{this.created=!0;let n=t.target.result,r=n.createObjectStore(this.name,{keyPath:this.scheme.keyPath});for(let e of this.scheme.indexes)r.createIndex(e.name,e.name,{unique:e.unique});this.db=n,this.dispatchEvent(open),e(this)},n.onsuccess=t=>{this.created||(this.db=t.target.result,this.dispatchEvent(open),e(this))},n.onerror=()=>{t(n.error)}})}[Symbol.asyncIterator](){let e=this.db.transaction(this.name,"readwrite").objectStore(this.name).openCursor(),t=e=>new Promise(n=>e.onsuccess=r=>{let s=r.target.result;n([s,t(e)])}),n=t(e);return{async next(){let[e,t]=await n;return n=t,e?(e.continue(),Promise.resolve({done:!1,value:e.value})):Promise.resolve({done:!0,value:null})}}}}let onopen=new Event("open"),onconnection=new Event("connection"),onset=new Event("set"),ondelete=new Event("delete");class OctoStore extends OctoDB{constructor(e,t){super(e,t)}async filter(e){let t=[];for await(let n of this.entries)e(n)&&t.push(n);return t}async every(e){for await(let t of this.entries)if(!e(t))return!1;return!0}async slice(e,t){let n=[];for await(let r of this.entries)if(0>=e&&0<=t&&n.push(r),0==t)break;return n}async all(){let e=[];for await(let t of this.entries)e.push(t);return e}async concat(e){for(let t of e)await(this.entries[t[this.scheme.keyPath]]=t)}async transaction(e){let t=Object.assign({},this);try{await e(t)}catch(e){throw e}await e(this)}}
